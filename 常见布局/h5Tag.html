<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="./normalize.css" type="text/css" rel="stylesheet" />
    <style>
        div,
        input,
        span {
            box-sizing: border-box;
            background: red;
            width: 200px;
            height: 200px;
            padding: 20px;
            margin: 20px;
        }

        .p-0 {
            padding: 0;
        }
        .demo-0,.demo-0 div {
            margin: 0;
            padding: 0;
            border: 1px solid #000 !important;
            box-shadow: 5px 5px 6px darkcyan;
            

        }
        
        .demo-0 div{
            background-color: #fff;
            width: 80px;height: 80px;margin-right: 20px;margin-bottom: 20px;
            padding: 0;
        }
        .demo-0 div:nth-child(3n){
         
         background:orange;
         margin-right: 0;
     }
    

        
    </style>
    <style>
        /* 居然要单独写   很碧池 */
        @import url('./h5Tag.css');
    </style>
</head>

<body>
    <p>实验分别比较行内元素和块状元素区别</p>
    <div>
        123
    </div>
    <input type="button" value="123">
    <span>123</span>

    <p>实验结果表明，
        1.行内元素设置padding有效，设置margin只有水平方向生效
        2.input,img等行内替换元素毫无压力
    </p>


    <p>BFC</p>
    <p>块状元素上下边距重叠情况</p>
    <div class="table">
        233
    </div>
    <div>
        233
    </div>
    <p>当一个元素包含在另一个元素中时，他们的顶和底外边距也会发生叠加</p>
    <div class="p-0">
        <div style="background: darkblue;height: 100px;width: 100px;" class="p-0"></div>
    </div>
    <p>本身边距发生重叠(前提有三个：空元素，有外边距，无内边距/边框ps以大的边距展示)</p>
    <p di="emptyDiv" style="margin-top:30px;margin-bottom:20px;background: skyblue;"></p>
    <div style="height: 0;"></div>

    <P>
        bfc形成条件说明
        1.float: left,right
        2.position: absllute,fixed
        3.dispaly: inline-block(所以行内替换元素无此类问题),table-cell,table-caption,inline-flex
        4.overflow: hiddden,scroll
    </P>

    <p>table-cell应用</p>
    <h6>等分布局</h6>
    <ul class="table-wrap">
        <li>001</li>
        <li>002</li>
        <li>003</li>
        <li>004</li>
        <li>005</li>
    </ul>
    <p>图片水平垂直居中</p>
    <div class="outer">
        <div class="table-wrap">
            <img src="https://s4.51cto.com/images/blog/202003/17/f84902630cd49eab16f7895cd73e3092.png" alt="logo" />
        </div>
    </div>
    <p>元素两端垂直对齐</p>
    <div class="content">
        <div class="left-box p-0">
            <img src="https://s4.51cto.com/images/blog/202003/17/f84902630cd49eab16f7895cd73e3092.png" alt="logo" />
        </div>
        <div class="right-box">
            <div>
                这是很多很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字这是很多文字。。。。。
            </div>
        </div>
    </div>
    <p>应用场景
        1.文字水平垂直居中
        2.图片水平垂直居中
        3.元素两端垂直对齐
        4.等高布局
        5.均分列表布局
        6.两栏自适应布局（即左侧宽度固定，右侧自动分配剩余空间ps:左侧宽度固定，右侧宽度自适应。布局原理也可以用BFC来解释，左侧和右侧都是BFC块，BFC块是不会和float块发生重叠的。）
    </p>
    <a href="https://blog.csdn.net/messagebox_/article/details/82380913"
        onmousemove="window.status='Visit the Netscape home page (home.netscape.com)'; return true">博客链接</a>

    <p>解决照片上传flex布局排版问题</p>

    <div class="demo-0" style="width: 282px;height: 282px;background: rgba(0,0,0,1);display: flex;flex-wrap: wrap;margin: auto;border: 1px solid red;overflow: hidden;">
        <div ></div>
        <div ></div>
        <div ></div>
        <div ></div>
        <div ></div>
        <div ></div>
        <div ></div>
        <div ></div>
    </div>
    <p rel="pic">css轮播图</p>
    <div class="ani"></div>
</body>



<script>
    var result = [];

    function fn(n) {	//典型的斐波那契数列

        if (n == 1) {

            return 1;

        } else if (n == 2) {

            return 1;

        } else {

            if (result[n]) {

                return result[n];

            } else {

                result[n] = arguments.callee(n - 1) + arguments.callee(n - 2);

                return result[n];

            }

        }

    }
    console.log(fn(9))

    // class对象里面函数this指向问题
    class Dog {
        constructor() {
            this.name = 'adong';
        }

        start() {
            this.p().then(() => {
                console.log(this, "写成箭头函数指向上下文");
                // 上面如果是.then(function(){ //this是undefined  })
                this.say('sb')
            });
        }

        p() {
            return new Promise((resolve, reject) => {
                resolve('good');
            })
        }

        say(str) {
            console.log(this); console.log(this.name + str);
        }
    } let dog = new Dog();

    dog.start();


    // 字符串反转+“123456”=>“123，456”
    var str = "12345678"
    function re(str) {
        var i = 0, sum = "";
        while (i < str.length) {
            sum += str[str.length - i - 1]
            i++
        }
        return sum;
    }
    var tmp = "";
    // 连为什么i=1初始值都这么讲究，太牛逼了
    for (var i = 1; i <= re(str).length; i++) {
        tmp += re(str)[i - 1];
        if (i % 3 == 0 && i != re(str).length) {
            tmp += ',';
        }
    }
    // 字符串插入指定字符
    function insertStr(soure, start, newStr) {
        return soure.slice(0, start) + newStr + soure.slice(start);
    }
    var month = "201910"; var newmonth = insertStr(month, 4, ".");
    // 阻止冒泡方法
    function stopPropagation(e) {
        e = e || window.event;
        if (e.stopPropagation) { //W3C 阻止冒泡方法
            e.stopPropagation();
        } else {
            e.cancelBubble = true;	//IE 阻止冒泡方法
        }
    }
    console.log(document.querySelector("p[rel = 'pic']").innerHTML,document.querySelector("p[rel = 'pic']").innerText)
    // 区别在于前者设置值会解析赋值元素的标签内容，后者不会

    
    //vue脚手架创建
    //     npm install -g @vue/cli
    // vue init webpack myProject
    // vue create myProject

    //值类型在栈开辟空间存储
    // 引用类型把引用地址存储在栈，把数据存储在堆里面（对象属性值也是在堆里面）
</script>

</html>